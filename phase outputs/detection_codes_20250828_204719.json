{
  "total_codes": 4,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(df['Window Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "explanation": "This code detects rows where both Window Seat and Aisle Seat are marked as True, indicating contradictory values in these columns.",
      "test_description": "To test this detection, check rows where both Window Seat and Aisle Seat are marked as True. Verify that the flag_status column is updated to 1 for those rows.",
      "safety_notes": "Ensure that the normalization of boolean values is consistent with the expected True values. This code assumes that only one of Window Seat or Aisle Seat should be True per row."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(df['Status'].notna()) & ((pd.to_datetime(df['Departure Datetime'], errors='coerce') > pd.to_datetime(df['Arrival Datetime'], errors='coerce')) | (pd.to_datetime(df['Departure Time'], errors='coerce') > pd.to_datetime(df['Arrival Time'], errors='coerce'))), 'flag_status'] |= 2",
      "explanation": "This code detects data consistency issues where the Status conflicts with the operational timestamps (Departure Datetime, Arrival Datetime, Departure Time, Arrival Time). It checks if the Status is not null and if the Departure Datetime is after the Arrival Datetime or the Departure Time is after the Arrival Time.",
      "test_description": "To test this detection, you can create sample data where the Status conflicts with the operational timestamps. For example, set a Status indicating 'In Progress' while the Departure Time is after the Arrival Time.",
      "safety_notes": "Ensure that the timestamps are correctly formatted and consistent for accurate detection. Review the discrepancies between Status and operational timestamps to resolve the conflicts."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[(pd.to_datetime(df['Departure Datetime'], errors='coerce') > pd.to_datetime(df['Arrival Datetime'], errors='coerce')) & df['Departure Datetime'].notna() & df['Arrival Datetime'].notna(), 'flag_status'] |= 4",
      "explanation": "This code detects rows where the departure datetime is after the arrival datetime, violating the business logic. It converts the 'Departure Datetime' and 'Arrival Datetime' columns to datetime objects and checks if the departure datetime is greater than the arrival datetime.",
      "test_description": "Test by inserting a row where Departure Datetime is after Arrival Datetime and running the detection code. The flag_status should be updated to 4 for that row.",
      "safety_notes": "Ensure that the 'Departure Datetime' and 'Arrival Datetime' columns contain valid datetime values for accurate detection."
    },
    {
      "flag_value": 8,
      "detection_code": "df.loc[(pd.to_numeric(df['Duration (Hours)'], errors='coerce') < 0) & pd.to_numeric(df['Duration (Hours)'], errors='coerce').notna(), 'flag_status'] |= 8",
      "explanation": "This code detects and flags rows where the 'Duration (Hours)' column contains negative or unrealistic values.",
      "test_description": "Test by checking if the 'Duration (Hours)' column has any negative or unrealistic values.",
      "safety_notes": "Ensure that negative or unrealistic duration values are investigated and corrected to maintain data integrity."
    }
  ],
  "generation_timestamp": "2025-08-28T20:47:19.755856",
  "llm_model": "gpt-3.5-turbo"
}