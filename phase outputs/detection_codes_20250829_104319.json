{
  "total_codes": 3,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(df['Window Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "explanation": "This code checks each row in the DataFrame to see if both 'Window Seat' and 'Aisle Seat' columns are marked as true (considering various true representations like 'true', 't', 'yes', 'y', '1'). If both are true for the same row, it flags that row by setting the 'flag_status' to 1, indicating a data consistency issue where a passenger is incorrectly marked as being in both a window and an aisle seat simultaneously.",
      "test_description": "To test this code, create a DataFrame with columns 'Window Seat' and 'Aisle Seat'. Populate some rows where both columns are true, and others where only one or neither is true. Apply the code and verify that only the rows with both columns set to true are flagged in the 'flag_status' column.",
      "safety_notes": "The code safely handles different representations of boolean true values and ensures no data type assumptions are made without conversion and normalization. It directly modifies the 'flag_status' column in the DataFrame, so ensure this column exists and is intended for use as a flagging mechanism."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(pd.to_datetime(df['Departure Date/Time'], errors='coerce') > pd.to_datetime(df['Arrival Date/Time'], errors='coerce')) & pd.to_datetime(df['Departure Date/Time'], errors='coerce').notna() & pd.to_datetime(df['Arrival Date/Time'], errors='coerce').notna(), 'flag_status'] |= 2",
      "explanation": "This code checks for rows where the 'Departure Date/Time' is later than the 'Arrival Date/Time'. Both dates are converted to datetime objects, and the condition is only checked where both dates are valid (not NaT). If the condition is true, the flag status for that row is updated by bitwise OR operation with the value 2.",
      "test_description": "To test this code, create a DataFrame with columns 'Departure Date/Time' and 'Arrival Date/Time' containing both valid and invalid date strings. Ensure that some rows have a departure date/time later than the arrival date/time. Apply the code and verify that the 'flag_status' column correctly flags these rows with the value 2.",
      "safety_notes": "The code safely handles invalid date formats by using 'errors=coerce' which converts invalid dates to NaT (Not a Time), ensuring the comparison does not raise errors. It also checks that both dates are not NaT before comparing them, preventing false positives from rows with missing data."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[(pd.to_numeric(df['Layovers'], errors='coerce').fillna(0).astype(int) != df['Layover Locations'].fillna('').astype(str).apply(lambda x: len([i for i in re.split(r'[;,|>]|->', str(x)) if i.strip()]))), 'flag_status'] |= 4",
      "explanation": "Checks for mismatch between Layovers and Layover Locations",
      "test_description": "Create rows where Layovers does not equal number of items in Layover Locations",
      "safety_notes": "Handles missing values, multiple delimiters (;,|,>,->)."
    }
  ],
  "generation_timestamp": "2025-08-29T10:43:19.997456",
  "llm_model": "gpt-4-turbo"
}