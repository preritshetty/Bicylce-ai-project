{
  "execution_summary": {
    "total_rows": 10016,
    "flagged_rows": 6154,
    "clean_rows": 3862,
    "flagged_percentage": 61.44,
    "total_detections": 12252,
    "execution_time_seconds": 0.04,
    "successful_codes": 4,
    "failed_codes": 0,
    "success_rate": 100.0,
    "timestamp": "2025-08-27T23:50:44.136027"
  },
  "individual_results": [
    {
      "flag_value": 1,
      "success": true,
      "rows_detected": 2425,
      "explanation": "This code detects rows where both Window_Seat and Aisle_Seat columns have contradictory values (both True).",
      "code": "df.loc[(df['Window_Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle_Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "error": null
    },
    {
      "flag_value": 2,
      "success": true,
      "rows_detected": 4913,
      "explanation": "This code detects conflicts between the 'Status' column and the 'Departure_DateTime' and 'Arrival_DateTime' columns. It flags rows where the 'Status' is not null and either the departure time is after the arrival time, or the departure/arrival time is in the future.",
      "code": "df.loc[(df['Status'].notna()) & ((pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime(df['Arrival_DateTime'], errors='coerce')) | (pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime('now')) | (pd.to_datetime(df['Arrival_DateTime'], errors='coerce') > pd.to_datetime('now'))), 'flag_status'] |= 2",
      "error": null
    },
    {
      "flag_value": 4,
      "success": true,
      "rows_detected": 4913,
      "explanation": "This code detects rows where the Departure_DateTime is after the Arrival_DateTime, which violates the business logic of a flight departure occurring after arrival.",
      "code": "df.loc[(pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime(df['Arrival_DateTime'], errors='coerce')) & df['Departure_DateTime'].notna() & df['Arrival_DateTime'].notna(), 'flag_status'] |= 4",
      "error": null
    },
    {
      "flag_value": 8,
      "success": true,
      "rows_detected": 1,
      "explanation": "This code detects and flags rows where the 'Duration_Hours' column contains negative or unrealistic values.",
      "code": "df.loc[(pd.to_numeric(df['Duration_Hours'], errors='coerce') < 0) & pd.to_numeric(df['Duration_Hours'], errors='coerce').notna(), 'flag_status'] |= 8",
      "error": null
    }
  ],
  "flag_breakdown": {
    "individual_flags": {
      "1": 2425,
      "2": 4913,
      "4": 4913,
      "8": 1
    },
    "combined_flags": {
      "1": 1240,
      "6": 3728,
      "7": 1185,
      "8": 1
    },
    "flag_combinations": [
      {
        "flag_status": 1,
        "individual_flags": [
          1
        ],
        "flag_description": "Flags 1",
        "row_count": 1240,
        "binary_representation": "1"
      },
      {
        "flag_status": 6,
        "individual_flags": [
          2,
          4
        ],
        "flag_description": "Flags 2+4",
        "row_count": 3728,
        "binary_representation": "110"
      },
      {
        "flag_status": 7,
        "individual_flags": [
          1,
          2,
          4
        ],
        "flag_description": "Flags 1+2+4",
        "row_count": 1185,
        "binary_representation": "111"
      },
      {
        "flag_status": 8,
        "individual_flags": [
          8
        ],
        "flag_description": "Flags 8",
        "row_count": 1,
        "binary_representation": "1000"
      }
    ]
  }
}