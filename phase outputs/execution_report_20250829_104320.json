{
  "execution_summary": {
    "total_rows": 10016,
    "flagged_rows": 8727,
    "clean_rows": 1289,
    "flagged_percentage": 87.13,
    "total_detections": 14041,
    "execution_time_seconds": 0.05,
    "successful_codes": 3,
    "failed_codes": 0,
    "success_rate": 100.0,
    "timestamp": "2025-08-29T10:43:20.100652"
  },
  "individual_results": [
    {
      "flag_value": 1,
      "success": true,
      "rows_detected": 2425,
      "explanation": "This code checks each row in the DataFrame to see if both 'Window Seat' and 'Aisle Seat' columns are marked as true (considering various true representations like 'true', 't', 'yes', 'y', '1'). If both are true for the same row, it flags that row by setting the 'flag_status' to 1, indicating a data consistency issue where a passenger is incorrectly marked as being in both a window and an aisle seat simultaneously.",
      "code": "df.loc[(df['Window Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "error": null
    },
    {
      "flag_value": 2,
      "success": true,
      "rows_detected": 4913,
      "explanation": "This code checks for rows where the 'Departure Date/Time' is later than the 'Arrival Date/Time'. Both dates are converted to datetime objects, and the condition is only checked where both dates are valid (not NaT). If the condition is true, the flag status for that row is updated by bitwise OR operation with the value 2.",
      "code": "df.loc[(pd.to_datetime(df['Departure Date/Time'], errors='coerce') > pd.to_datetime(df['Arrival Date/Time'], errors='coerce')) & pd.to_datetime(df['Departure Date/Time'], errors='coerce').notna() & pd.to_datetime(df['Arrival Date/Time'], errors='coerce').notna(), 'flag_status'] |= 2",
      "error": null
    },
    {
      "flag_value": 4,
      "success": true,
      "rows_detected": 6703,
      "explanation": "Checks for mismatch between Layovers and Layover Locations",
      "code": "df.loc[(pd.to_numeric(df['Layovers'], errors='coerce').fillna(0).astype(int) != df['Layover Locations'].fillna('').astype(str).apply(lambda x: len([i for i in re.split(r'[;,|>]|->', str(x)) if i.strip()]))), 'flag_status'] |= 4",
      "error": null
    }
  ],
  "flag_breakdown": {
    "individual_flags": {
      "1": 2425,
      "2": 4913,
      "4": 6703
    },
    "combined_flags": {
      "1": 382,
      "6": 2513,
      "5": 858,
      "4": 2574,
      "7": 758,
      "2": 1215,
      "3": 427
    },
    "flag_combinations": [
      {
        "flag_status": 1,
        "individual_flags": [
          1
        ],
        "flag_description": "Flags 1",
        "row_count": 382,
        "binary_representation": "1"
      },
      {
        "flag_status": 6,
        "individual_flags": [
          2,
          4
        ],
        "flag_description": "Flags 2+4",
        "row_count": 2513,
        "binary_representation": "110"
      },
      {
        "flag_status": 5,
        "individual_flags": [
          1,
          4
        ],
        "flag_description": "Flags 1+4",
        "row_count": 858,
        "binary_representation": "101"
      },
      {
        "flag_status": 4,
        "individual_flags": [
          4
        ],
        "flag_description": "Flags 4",
        "row_count": 2574,
        "binary_representation": "100"
      },
      {
        "flag_status": 7,
        "individual_flags": [
          1,
          2,
          4
        ],
        "flag_description": "Flags 1+2+4",
        "row_count": 758,
        "binary_representation": "111"
      },
      {
        "flag_status": 2,
        "individual_flags": [
          2
        ],
        "flag_description": "Flags 2",
        "row_count": 1215,
        "binary_representation": "10"
      },
      {
        "flag_status": 3,
        "individual_flags": [
          1,
          2
        ],
        "flag_description": "Flags 1+2",
        "row_count": 427,
        "binary_representation": "11"
      }
    ]
  }
}