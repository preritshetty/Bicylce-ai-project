{
  "total_codes": 4,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(df['Window Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "explanation": "This code detects rows where both Window Seat and Aisle Seat are marked as True, indicating a contradictory situation where a seat is marked as both window and aisle seat simultaneously.",
      "test_description": "Test by checking rows where both Window Seat and Aisle Seat are marked as True. The detection code should flag these rows.",
      "safety_notes": "Ensure that the normalization of boolean values is consistent and covers all possible true representations to avoid missing any contradictory values."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(df['Status'].notna()) & ((pd.to_datetime(df['Departure Datetime'], errors='coerce') > pd.to_datetime(df['Arrival Datetime'], errors='coerce')) | (pd.to_datetime(df['Departure Time'], errors='coerce') > pd.to_datetime(df['Arrival Time'], errors='coerce'))), 'flag_status'] |= 2",
      "explanation": "This code detects inconsistencies between the Status column and operational timestamps by checking if the Departure Datetime is after the Arrival Datetime or if the Departure Time is after the Arrival Time when the Status is not null.",
      "test_description": "Test by checking if the flag_status column is updated to 2 for rows where the Status column has a value and the Departure Datetime is after the Arrival Datetime or the Departure Time is after the Arrival Time.",
      "safety_notes": "Ensure that the columns used for timestamp comparison are correctly formatted as datetime objects to avoid errors. Review the flagged rows to resolve the inconsistencies between Status and operational timestamps."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[(pd.to_datetime(df['Departure Datetime'], errors='coerce') > pd.to_datetime(df['Arrival Datetime'], errors='coerce')) & df['Departure Datetime'].notna() & df['Arrival Datetime'].notna(), 'flag_status'] |= 4",
      "explanation": "This code detects rows where the departure datetime is after the arrival datetime, which violates the business logic. It ensures that the departure datetime is before the arrival datetime.",
      "test_description": "Test the detection by creating sample data where some rows have departure datetime after arrival datetime. Apply the detection code and check if the 'flag_status' is correctly set to 4 for those rows.",
      "safety_notes": "Ensure that the datetime columns are properly formatted and contain valid datetime values for accurate detection."
    },
    {
      "flag_value": 8,
      "detection_code": "df.loc[(pd.to_numeric(df['Layovers'], errors='coerce').fillna(0).astype(int) != df['Layover Locations'].fillna('').astype(str).apply(lambda x: len([i for i in re.split(r'[;,|>]|->', str(x)) if i.strip()]))), 'flag_status'] |= 8",
      "explanation": "Checks for mismatch between Layovers and Layover Locations",
      "test_description": "Create rows where Layovers does not equal number of items in Layover Locations",
      "safety_notes": "Handles missing values, multiple delimiters (;,|,>,->)."
    }
  ],
  "generation_timestamp": "2025-08-28T17:08:26.359031",
  "llm_model": "gpt-3.5-turbo"
}