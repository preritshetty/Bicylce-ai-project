{
  "total_codes": 4,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(df['Window_Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle_Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "explanation": "This code detects rows where both Window_Seat and Aisle_Seat columns have contradictory values (both True).",
      "test_description": "Test by checking if the 'flag_status' column is updated for rows where both Window_Seat and Aisle_Seat are True.",
      "safety_notes": "Ensure that the normalization of boolean values is consistent and covers all possible true representations."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(df['Status'].notna()) & ((pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime(df['Arrival_DateTime'], errors='coerce')) | (pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime('now')) | (pd.to_datetime(df['Arrival_DateTime'], errors='coerce') > pd.to_datetime('now'))), 'flag_status'] |= 2",
      "explanation": "This code detects conflicts between the 'Status' column and the 'Departure_DateTime' and 'Arrival_DateTime' columns. It flags rows where the 'Status' is not null and either the departure time is after the arrival time, or the departure/arrival time is in the future.",
      "test_description": "Test by checking rows where 'Status' is not null and the departure time is after the arrival time, or the departure/arrival time is in the future.",
      "safety_notes": "Ensure that the 'Departure_DateTime' and 'Arrival_DateTime' columns are correctly formatted as datetime objects before running this detection code."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[(pd.to_datetime(df['Departure_DateTime'], errors='coerce') > pd.to_datetime(df['Arrival_DateTime'], errors='coerce')) & df['Departure_DateTime'].notna() & df['Arrival_DateTime'].notna(), 'flag_status'] |= 4",
      "explanation": "This code detects rows where the Departure_DateTime is after the Arrival_DateTime, which violates the business logic of a flight departure occurring after arrival.",
      "test_description": "To test this detection, create sample data where Departure_DateTime is set after Arrival_DateTime in some rows. Apply the detection code and check if the 'flag_status' column is updated for those rows.",
      "safety_notes": "Ensure that the Departure_DateTime and Arrival_DateTime columns are properly formatted as datetime objects before running this detection code."
    },
    {
      "flag_value": 8,
      "detection_code": "df.loc[(pd.to_numeric(df['Duration_Hours'], errors='coerce') < 0) & pd.to_numeric(df['Duration_Hours'], errors='coerce').notna(), 'flag_status'] |= 8",
      "explanation": "This code detects and flags rows where the 'Duration_Hours' column contains negative or unrealistic values.",
      "test_description": "Test by checking if the 'Duration_Hours' column has any negative or unrealistic values.",
      "safety_notes": "Ensure that negative or unrealistic duration values are investigated and corrected to maintain data integrity."
    }
  ],
  "generation_timestamp": "2025-08-27T23:50:44.042176",
  "llm_model": "gpt-3.5-turbo"
}