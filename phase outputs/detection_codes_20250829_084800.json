{
  "total_codes": 4,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(df['Window Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['Aisle Seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 1",
      "explanation": "This code detects rows where both Window Seat and Aisle Seat are marked as True, indicating a contradictory situation. It flags such rows for further investigation.",
      "test_description": "To test this detection, check rows where both Window Seat and Aisle Seat are marked as True. After running the code, the 'flag_status' column will be updated for those rows.",
      "safety_notes": "Ensure that the normalization of boolean values is consistent and covers all possible representations of True values to avoid missing any contradictory cases."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(df['Status'].notna()) & ((pd.to_datetime(df['Departure Date Time'], errors='coerce') > pd.to_datetime(df['Arrival Date Time'], errors='coerce')) | (pd.to_datetime(df['Departure Date Time'], errors='coerce') > pd.to_datetime('now')) | (pd.to_datetime(df['Arrival Date Time'], errors='coerce') > pd.to_datetime('now'))), 'flag_status'] |= 2",
      "explanation": "This code detects conflicts between the 'Status' column and the 'Departure Date Time' and 'Arrival Date Time' columns. It flags rows where the 'Status' is not null and either the 'Departure Date Time' is after the 'Arrival Date Time', or the 'Departure Date Time' or 'Arrival Date Time' is in the future.",
      "test_description": "To test this detection, check rows where the 'Status' is not null and the 'Departure Date Time' is after the 'Arrival Date Time', or the 'Departure Date Time' or 'Arrival Date Time' is in the future.",
      "safety_notes": "Ensure that the 'Departure Date Time' and 'Arrival Date Time' columns are properly formatted as datetime objects before running this detection code."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[(pd.to_datetime(df['Departure Date Time'], errors='coerce') > pd.to_datetime(df['Arrival Date Time'], errors='coerce')) & df['Departure Date Time'].notna() & df['Arrival Date Time'].notna(), 'flag_status'] |= 4",
      "explanation": "This code detects rows where the Departure Date Time is after the Arrival Date Time, which violates the business logic. It ensures that the departure date is before the arrival date.",
      "test_description": "Test by checking if the 'flag_status' is flagged as 4 for rows where Departure Date Time is after Arrival Date Time.",
      "safety_notes": "Ensure that the date columns are properly formatted and contain valid date values for accurate detection."
    },
    {
      "flag_value": 8,
      "detection_code": "df.loc[(pd.to_numeric(df['Duration Hours'], errors='coerce') < 0) & pd.to_numeric(df['Duration Hours'], errors='coerce').notna(), 'flag_status'] |= 8",
      "explanation": "This code detects negative or unrealistic duration values in the 'Duration Hours' column by converting the column to numeric and checking for values less than 0.",
      "test_description": "Test by checking if the 'Duration Hours' column contains any negative or unrealistic values.",
      "safety_notes": "Ensure that the 'Duration Hours' column only contains valid and realistic duration values for accurate analysis."
    }
  ],
  "generation_timestamp": "2025-08-29T08:48:00.095853",
  "llm_model": "gpt-3.5-turbo"
}